/**
 * 难度：简单
 * 题目：191. 位1的个数
 * 相似题目：
 * 
  编写一个函数，输入是一个无符号整数，
  返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

  示例 1：
  输入：00000000000000000000000000001011
  输出：3
  解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

  示例 2：
  输入：00000000000000000000000010000000
  输出：1
  解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

  示例 3：
  输入：11111111111111111111111111111101
  输出：31
  解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

  提示：
  请注意，在某些语言（如 Java）中，没有无符号整数类型。
  在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，
  因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
  在 Java 中，编译器使用二进制补码记法来表示有符号整数。
  因此，在上面的 示例 3 中，输入表示有符号整数 -3。
   
  进阶:
  如果多次调用这个函数，你将如何优化你的算法？

 */

/**
 * @param {number} n - a positive integer
 * @return {number}
 */
/**@other
 * 解法一：循环+位运算移动
 * 1.给mask赋初值1，表示从最低位开始与1&，
 *  如果n&mask!=0,表示当前位为1，所以count++
 * 2.当前位判断完后，mask左移一位，继续与n的左一位相与，看是否为1
 * 3.32位二进制比较完毕后退出循环
 * 
 * 任何数字跟掩码1进行逻辑与运算，都可以获得这个数字都最低位
 * 检查下一位时，将掩码左移一位
 * 0000 0000 0000 0000 0000 0000 0000 0001 =>
 * 0000 0000 0000 0000 0000 0000 0000 0010
 * 
 * time:O(1)
 * space:O(1)
 * runtime:200ms 5%
 * memory usage:47.1MB 16%
 */
var hammingWeight = function(n) {
  let mask = 1;
  let count = 0;
  for (let i = 0; i < 32; i++) {
    if ((n & mask)!=0) {
      count++;
    }
    mask <<= 1;
  }
  return count;
};

/**@other
 * 解法二：位操作技巧
 * n & (n-1): 清零最低位的1
 * 每次把数字最后一个二进制位1反转为0，sum++
 * 当没有1可反的时候，数字变成了0
 * 
 * n数字的二进制的最低位的1总是对应n-1数字的二进制的0
 * 相与后，其它位不变，当前位变成0
 * time:O(1), 最坏情况下n中所有位均为1.
 * space:O(1)
 * runtime:96ms 22%
 * memory usage:38.3MB 68%
 */
var hammingWeight = function(n) {
  let count = 0;
  while (n!=0) {
    // 清零最低位的1
    n = n & (n - 1);
    count++;
  }
  return count;
};